{"version":3,"file":"EditorManager.js","sourceRoot":"","sources":["../lib/EditorManager.ts"],"names":[],"mappings":"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","sourcesContent":["'use babel';\n/*!\n * Atom Bugs\n * Copyright(c) 2017 Williams Medina <williams.medinaa@gmail.com>\n * MIT Licensed\n */\nimport { BreakpointManager } from './BreakpointManager';\n\nexport class EditorManager {\n\n  private currentEditor: any;\n  private currentBreakMarker: any;\n  private breakpointHandler: Function;\n  private expressionHandler: Function;\n\n  constructor (private breakpointManager: BreakpointManager) {\n    this.breakpointHandler = this.breakpointListener.bind(this);\n    this.expressionHandler = this.expressionListener.bind(this);\n  }\n\n  createBreakMarker (editor, lineNumber) {\n    this.removeBreakMarker();\n    let range = [[lineNumber - 1, 0], [lineNumber - 1, 0]];\n    this.currentBreakMarker = editor.markBufferRange(range);\n    editor.decorateMarker(this.currentBreakMarker, {\n      type: 'line',\n      class: 'bugs-break-line'\n    })\n  }\n\n  removeBreakMarker () {\n    if (this.currentBreakMarker) {\n      this.currentBreakMarker.destroy();\n    }\n  }\n\n  addFeatures (editor) {\n    // Observe active editor\n    atom.workspace['observeActivePaneItem']((editor) => {\n      if (this.currentEditor && this.currentEditor.editorElement) {\n        // remove breakpoint handler\n        this.currentEditor.editorElement.removeEventListener('click', this.breakpointHandler);\n        this.currentEditor.editorElement.removeEventListener('mousemove', this.expressionHandler);\n        // remove expression evaluator\n      }\n      if (editor && editor.getPath && editor.editorElement) {\n        this.currentEditor = editor;\n        // add breakpoint handler\n        this.currentEditor.editorElement.addEventListener('click', this.breakpointHandler)\n        this.currentEditor.editorElement.addEventListener('mousemove', this.expressionHandler);\n      }\n    })\n  }\n\n  private breakpointListener (e) {\n    let element = e.target\n    if (element.classList.contains('line-number')) {\n      // toggle breakpoints\n      let sourceFile = this.currentEditor.getPath();\n      let lineNumber = Number(element.textContent)\n      let exists = this.breakpointManager.getBreakpoint(sourceFile, lineNumber)\n      if (exists) {\n        this.breakpointManager.removeBreakpoint(exists);\n      } else {\n        let range = [[lineNumber - 1, 0], [lineNumber - 1, 0]]\n        let marker = this.currentEditor.markBufferRange(range)\n        let decorator = this.currentEditor.decorateMarker(marker, {\n          type: 'line-number',\n          class: 'bugs-breakpoint'\n        })\n        this.breakpointManager.addBreakpoint(marker, lineNumber, sourceFile)\n      }\n    }\n  }\n\n  private  expressionListener (e) {\n    let sourceFile = this.currentEditor.getPath();\n    let lines = this.currentEditor.editorElement.querySelector('.lines');\n    var clientX = e.clientX;\n    var clientY = e.clientY;\n    let clientRect = lines.getBoundingClientRect();\n    let screenPosition = this.currentEditor.screenPositionForPixelPosition({\n      top: (clientY - clientRect.top) + this.currentEditor.editorElement.getScrollTop(),\n      left: (clientX - clientRect.left) + this.currentEditor.editorElement.getScrollLeft()\n    });\n    let bufferPosition = this.currentEditor.bufferPositionForScreenPosition(screenPosition);\n    let prevRow = this.currentEditor.buffer.previousNonBlankRow(bufferPosition.row);\n    let endRow = this.currentEditor\n      .buffer\n      .nextNonBlankRow(bufferPosition.row);\n    let startWord = bufferPosition;\n    let endWord = bufferPosition;\n    this.currentEditor.scanInBufferRange(/[ \\,\\{\\}\\(\\;\\)\\[\\]]+/gm, [[prevRow, 0], bufferPosition], (s) => {\n      if (s.matchText) {\n        startWord = s.range.end;\n      }\n    })\n    this.currentEditor.scanInBufferRange(/[ \\,\\{\\}\\(\\.\\;\\)\\[\\]\\n]+/g, [bufferPosition, [endRow, 0]], (s) => {\n      if (s.matchText) {\n        endWord = s.range.start;\n        s.stop();\n      }\n    })\n    let scanRange = [startWord, endWord];\n    // console.log(this.currentEditor.getTextInBufferRange(scanRange));\n  }\n}\n"]}